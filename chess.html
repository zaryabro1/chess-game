<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Elegant Web Chess</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Chess.js for move validation and game logic -->
  <!-- ✅ Use this instead of the previous chess.js script tag -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>


  <style>
    :root {
      --bg-gradient: radial-gradient(circle at top, #1f2933, #020617 60%);
      --card-bg: rgba(15, 23, 42, 0.9);
      --accent: #22c55e;
      --accent-soft: rgba(34, 197, 94, 0.12);
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --border-subtle: rgba(148, 163, 184, 0.4);
      --square-light: #f0d9b5;
      --square-dark: #b58863;
      --square-selected: #facc15;
      --square-move: #bef264;
      --shadow-soft: 0 22px 45px rgba(15, 23, 42, 0.8);
      --radius-lg: 22px;
      --radius-md: 14px;
      --transition-fast: 150ms ease-out;
      --transition-med: 220ms ease-out;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      background: var(--bg-gradient);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      color: var(--text-main);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .app {
      width: 100%;
      max-width: 1100px;
    }

    .card {
      background: var(--card-bg);
      border-radius: var(--radius-lg);
      padding: 22px 24px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(22px);
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
      margin-bottom: 18px;
    }

    .title-block h1 {
      font-size: 1.5rem;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .title-pill {
      padding: 3px 10px;
      border-radius: 999px;
      font-size: 0.73rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      border: 1px solid rgba(34, 197, 94, 0.4);
      background: radial-gradient(circle at top left, #22c55e33, transparent);
      color: #bbf7d0;
    }

    .title-block p {
      margin-top: 6px;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .status-chip {
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.78rem;
      color: var(--text-muted);
      background: radial-gradient(circle at top, rgba(148, 163, 184, 0.16), transparent);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #22c55e;
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.18);
    }

    .top-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 18px;
      flex-wrap: wrap;
    }

    .mode-toggle {
      display: inline-flex;
      padding: 3px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.5);
      position: relative;
      overflow: hidden;
    }

    .mode-toggle button {
      position: relative;
      z-index: 1;
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 0.8rem;
      padding: 6px 14px;
      border-radius: 999px;
      cursor: pointer;
      transition: color var(--transition-med);
      white-space: nowrap;
    }

    .mode-toggle button.active {
      color: #e5fbe9;
      font-weight: 500;
    }

    .mode-toggle .highlight {
      position: absolute;
      top: 3px;
      bottom: 3px;
      width: 50%;
      border-radius: 999px;
      background: linear-gradient(135deg, #22c55e, #4ade80);
      filter: drop-shadow(0 0 12px rgba(34, 197, 94, 0.5));
      transition: transform var(--transition-med);
    }

    .btn {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: radial-gradient(circle at top left, rgba(148, 163, 184, 0.28), rgba(15, 23, 42, 0.9));
      color: var(--text-main);
      padding: 8px 14px;
      font-size: 0.8rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: background var(--transition-fast), border-color var(--transition-fast), transform 120ms ease-out;
    }

    .btn:hover {
      border-color: rgba(209, 213, 219, 0.9);
      transform: translateY(-1px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-primary {
      border-color: rgba(34, 197, 94, 0.85);
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.5), rgba(15, 23, 42, 0.95));
      color: #ecfdf3;
    }

    .btn-pill-icon {
      font-size: 1rem;
    }

    .content {
      display: grid;
      grid-template-columns: minmax(0, 0.9fr) minmax(260px, 0.75fr);
      gap: 20px;
    }

    @media (max-width: 900px) {
      .content {
        grid-template-columns: minmax(0, 1fr);
      }
      .card {
        padding: 18px 16px 20px;
      }
    }

    .board-wrapper {
      display: flex;
      justify-content: center;
    }

    .board {
      width: min(78vmin, 480px);
      max-width: 100%;
      aspect-ratio: 1;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 2px;
      padding: 8px;
      border-radius: 24px;
      background: radial-gradient(circle at top, rgba(148, 163, 184, 0.3), rgba(15, 23, 42, 0.95));
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.8);
      position: relative;
    }

    .board::after {
      content: "";
      position: absolute;
      inset: 5px;
      border-radius: 20px;
      border: 1px solid rgba(15, 23, 42, 0.4);
      pointer-events: none;
    }

    .square {
      position: relative;
      width: 100%;
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(1.6rem, 2.6vw, 2.3rem);
      cursor: pointer;
      transition: transform var(--transition-fast), box-shadow var(--transition-fast), background-color var(--transition-fast);
      user-select: none;
    }

    .square.light {
      background: var(--square-light);
    }

    .square.dark {
      background: var(--square-dark);
    }

    .square:hover {
      box-shadow: inset 0 0 0 2px rgba(15, 23, 42, 0.3);
      transform: translateY(-1px);
    }

    .square.selected {
      box-shadow: inset 0 0 0 3px rgba(15, 23, 42, 0.7), 0 0 0 2px rgba(234, 179, 8, 0.75);
      background: var(--square-selected);
    }

    .square.move-highlight {
      box-shadow: inset 0 0 0 3px rgba(22, 101, 52, 0.85);
      background: var(--square-move);
    }

    .square-piece {
      transform: translateY(1px);
      font-weight: 900;
      filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3));
    }

    .square-piece.piece-white {
      color: #ffffff;
      text-shadow: 0 0 2px rgba(0, 0, 0, 0.5), 0 0 4px rgba(0, 0, 0, 0.3);
    }

    .square-piece.piece-black {
      color: #000000;
      text-shadow: 0 0 2px rgba(255, 255, 255, 0.3), 0 0 4px rgba(255, 255, 255, 0.2);
    }

    .coord-file,
    .coord-rank {
      position: absolute;
      font-size: 0.58rem;
      color: rgba(15, 23, 42, 0.75);
      font-weight: 600;
      pointer-events: none;
    }

    .coord-file {
      bottom: 3px;
      right: 4px;
    }

    .coord-rank {
      top: 3px;
      left: 4px;
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .panel-section {
      border-radius: var(--radius-md);
      border: 1px solid var(--border-subtle);
      padding: 10px 12px;
      background: radial-gradient(circle at top left, rgba(148, 163, 184, 0.2), rgba(15, 23, 42, 0.92));
    }

    .panel-section h2 {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .turn-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
    }

    .turn-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
    }

    .turn-badge {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      box-shadow: 0 0 0 4px rgba(15, 23, 42, 0.7);
    }

    .turn-badge.white {
      background: #f9fafb;
    }

    .turn-badge.black {
      background: #020617;
    }

    .status-text {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .game-status-main {
      font-size: 0.83rem;
    }

    .status-strong {
      color: #facc15;
      font-weight: 500;
    }

    .status-win {
      color: #4ade80;
      font-weight: 600;
    }

    .status-draw {
      color: #38bdf8;
      font-weight: 500;
    }

    .mode-hint {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .mode-hint span {
      color: #bbf7d0;
      font-weight: 500;
    }

    .moves-list {
      max-height: 260px;
      overflow: auto;
      padding-right: 4px;
      scrollbar-width: thin;
      scrollbar-color: rgba(148, 163, 184, 0.6) transparent;
    }

    .moves-list::-webkit-scrollbar {
      width: 6px;
    }

    .moves-list::-webkit-scrollbar-track {
      background: transparent;
    }

    .moves-list::-webkit-scrollbar-thumb {
      background: rgba(148, 163, 184, 0.7);
      border-radius: 999px;
    }

    .moves-grid {
      display: grid;
      grid-template-columns: auto 1fr 1fr;
      grid-auto-rows: auto;
      gap: 2px 8px;
      font-size: 0.8rem;
    }

    .move-index {
      color: var(--text-muted);
      text-align: right;
      padding-right: 2px;
    }

    .move-cell {
      padding: 2px 4px;
      border-radius: 10px;
      cursor: default;
    }

    .move-cell.white {
      color: #f9fafb;
      background: rgba(148, 163, 184, 0.18);
    }

    .move-cell.black {
      color: #d1fae5;
      background: var(--accent-soft);
    }

    .empty-cell {
      opacity: 0.4;
    }

    .hint-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .hint-pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      font-size: 0.7rem;
    }

    .chip-elo {
      font-size: 0.73rem;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px dashed rgba(34, 197, 94, 0.6);
      color: #bbf7d0;
    }

    .elo-selector {
      padding: 6px 14px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: radial-gradient(circle at top left, rgba(148, 163, 184, 0.28), rgba(15, 23, 42, 0.9));
      color: var(--text-main);
      font-size: 0.8rem;
      cursor: pointer;
      transition: background var(--transition-fast), border-color var(--transition-fast);
      outline: none;
    }

    .elo-selector:hover {
      border-color: rgba(209, 213, 219, 0.9);
    }

    .elo-selector:focus {
      border-color: rgba(34, 197, 94, 0.85);
    }

    /* Checkmate Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(2, 6, 23, 0.85);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn var(--transition-med);
    }

    .modal-overlay.show {
      display: flex;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    .modal-content {
      background: var(--card-bg);
      border-radius: var(--radius-lg);
      padding: 32px 28px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow: var(--shadow-soft), 0 0 60px rgba(34, 197, 94, 0.2);
      max-width: 420px;
      width: 90%;
      text-align: center;
      animation: slideUp var(--transition-med) ease-out;
      position: relative;
    }

    @keyframes slideUp {
      from {
        transform: translateY(20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .modal-icon {
      font-size: 4rem;
      margin-bottom: 16px;
      filter: drop-shadow(0 4px 12px rgba(34, 197, 94, 0.4));
    }

    .modal-title {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-main);
    }

    .modal-winner {
      font-size: 1.1rem;
      color: var(--text-muted);
      margin-bottom: 24px;
    }

    .modal-winner .winner-name {
      color: #4ade80;
      font-weight: 600;
      font-size: 1.2rem;
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .modal-actions .btn {
      min-width: 120px;
      justify-content: center;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <header>
        <div class="title-block">
          <div style="display:flex; align-items:center; gap:10px;">
            <h1>Silkboard Chess</h1>
            <span class="title-pill">Web · Play · Learn</span>
          </div>
          <p>Elegant board, smooth interactions. Battle a friend or challenge bots from 300 to 1500 Elo.</p>
        </div>
        <div class="status-chip">
          <span class="status-dot"></span>
          Live board · No backend needed
        </div>
      </header>

      <div class="top-bar">
        <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
          <div class="mode-toggle" id="modeToggle">
            <div class="highlight" id="modeHighlight"></div>
            <button type="button" data-mode="human" class="active">
              2 Players
            </button>
            <button type="button" data-mode="bot">
              Vs Bot
            </button>
          </div>

          <select id="eloSelector" class="elo-selector" style="display: none;">
            <option value="300">300 Elo</option>
            <option value="500">500 Elo</option>
            <option value="700">700 Elo</option>
            <option value="900">900 Elo</option>
            <option value="1100">1100 Elo</option>
            <option value="1300">1300 Elo</option>
            <option value="1500">1500 Elo</option>
          </select>
        </div>

        <button type="button" class="btn btn-primary" id="newGameBtn">
          <span class="btn-pill-icon">♻️</span>
          New game
        </button>
      </div>

      <div class="content">
        <div class="board-wrapper">
          <div id="board" class="board"></div>
        </div>

        <div class="side-panel">
          <section class="panel-section">
            <h2>Game state</h2>
            <div class="turn-row">
              <div class="turn-indicator">
                <div id="turnBadge" class="turn-badge white"></div>
                <span id="turnLabel">White to move</span>
              </div>
              <div class="chip-elo" id="modeLabel">Mode: 2 Players</div>
            </div>
            <div class="game-status-main" id="gameStatusText">
              Ready. Tap a piece to start.
            </div>
            <div class="mode-hint" id="modeHint">
              In <span>2 Players</span> mode, both sides are controlled on this device.
            </div>
          </section>

          <section class="panel-section">
            <h2>Moves</h2>
            <div class="moves-list" id="movesContainer">
              <div class="moves-grid" id="movesGrid"></div>
            </div>
            <div class="hint-row">
              <span class="hint-pill">Tip</span>
              <span class="status-text">Click a piece, then click its destination. Illegal moves are ignored.</span>
            </div>
          </section>
        </div>
      </div>
    </div>
  </div>

  <!-- Checkmate Modal -->
  <div class="modal-overlay" id="checkmateModal">
    <div class="modal-content">
      <div class="modal-icon">♔</div>
      <h2 class="modal-title">Checkmate!</h2>
      <div class="modal-winner">
        <span class="winner-name" id="winnerName">White</span> wins the game!
      </div>
      <div class="modal-actions">
        <button type="button" class="btn btn-primary" id="modalNewGameBtn">
          <span class="btn-pill-icon">♻️</span>
          New Game
        </button>
        <button type="button" class="btn" id="modalCloseBtn">
          Close
        </button>
      </div>
    </div>
  </div>

  <script>
    // --- Game setup ---
    const boardEl = document.getElementById("board");
    const movesGridEl = document.getElementById("movesGrid");
    const turnBadgeEl = document.getElementById("turnBadge");
    const turnLabelEl = document.getElementById("turnLabel");
    const gameStatusTextEl = document.getElementById("gameStatusText");
    const modeLabelEl = document.getElementById("modeLabel");
    const modeHintEl = document.getElementById("modeHint");
    const modeToggleEl = document.getElementById("modeToggle");
    const modeHighlightEl = document.getElementById("modeHighlight");
    const newGameBtn = document.getElementById("newGameBtn");
    const checkmateModal = document.getElementById("checkmateModal");
    const winnerNameEl = document.getElementById("winnerName");
    const modalNewGameBtn = document.getElementById("modalNewGameBtn");
    const modalCloseBtn = document.getElementById("modalCloseBtn");
    const eloSelector = document.getElementById("eloSelector");

    let game = new Chess();
    let selectedSquare = null;
    let possibleMoves = [];
    let lastMove = null;
    let mode = "human"; // 'human' | 'bot'
    let botElo = 300; // Current bot Elo level
    let botThinking = false;
    let movePairs = []; // [ {index, white, black}, ... ]

    const files = ["a", "b", "c", "d", "e", "f", "g", "h"];

    // Unicode pieces
    const PIECE_SYMBOLS = {
      w: {
        p: "♙",
        r: "♖",
        n: "♘",
        b: "♗",
        q: "♕",
        k: "♔",
      },
      b: {
        p: "♟",
        r: "♜",
        n: "♞",
        b: "♝",
        q: "♛",
        k: "♚",
      },
    };

    function createBoardSquares() {
      boardEl.innerHTML = "";
      // rank 8 at top, rank 1 at bottom (white at bottom)
      for (let rank = 8; rank >= 1; rank--) {
        for (let fileIndex = 0; fileIndex < 8; fileIndex++) {
          const file = files[fileIndex];
          const squareName = file + rank;

          const square = document.createElement("div");
          square.classList.add("square");
          const isDark = (fileIndex + rank) % 2 === 0;
          square.classList.add(isDark ? "dark" : "light");
          square.dataset.square = squareName;

          const pieceSpan = document.createElement("span");
          pieceSpan.classList.add("square-piece");
          square.appendChild(pieceSpan);

          // Coordinates on outer rank/file
          if (rank === 1) {
            const coordFile = document.createElement("span");
            coordFile.classList.add("coord-file");
            coordFile.textContent = file;
            square.appendChild(coordFile);
          }
          if (file === "a") {
            const coordRank = document.createElement("span");
            coordRank.classList.add("coord-rank");
            coordRank.textContent = rank;
            square.appendChild(coordRank);
          }

          boardEl.appendChild(square);
        }
      }
    }

    function pieceToChar(piece) {
      if (!piece) return "";
      return PIECE_SYMBOLS[piece.color][piece.type];
    }

    function renderPosition() {
      document
        .querySelectorAll(".square")
        .forEach((sq) => {
          const pieceEl = sq.querySelector(".square-piece");
          pieceEl.textContent = "";
          pieceEl.classList.remove("piece-white", "piece-black");
        });

      const squares = document.querySelectorAll(".square");
      squares.forEach((sq) => {
        const coord = sq.dataset.square;
        const piece = game.get(coord);
        const pieceEl = sq.querySelector(".square-piece");
        pieceEl.textContent = pieceToChar(piece);
        if (piece) {
          pieceEl.classList.add(piece.color === "w" ? "piece-white" : "piece-black");
        }
      });

      // Clear highlights
      squares.forEach((sq) => {
        sq.classList.remove("selected", "move-highlight");
      });

      // Selected square highlight
      if (selectedSquare) {
        const sel = document.querySelector(
          `.square[data-square="${selectedSquare}"]`
        );
        if (sel) sel.classList.add("selected");
      }

      // Last move highlight
      if (lastMove) {
        const fromSq = document.querySelector(
          `.square[data-square="${lastMove.from}"]`
        );
        const toSq = document.querySelector(
          `.square[data-square="${lastMove.to}"]`
        );
        if (fromSq) fromSq.classList.add("move-highlight");
        if (toSq) toSq.classList.add("move-highlight");
      }
    }

    function clearSelection() {
      selectedSquare = null;
      possibleMoves = [];
    }

    function updateStatusText() {
      const turn = game.turn(); // 'w' or 'b'
      const isGameOver = game.game_over();

      // Turn indicator
      turnBadgeEl.classList.remove("white", "black");
      turnBadgeEl.classList.add(turn === "w" ? "white" : "black");
      turnLabelEl.textContent =
        (turn === "w" ? "White" : "Black") +
        (isGameOver ? " (game over)" : " to move");

      // Mode label & hint
      if (mode === "human") {
        modeLabelEl.textContent = "Mode: 2 Players";
        modeHintEl.innerHTML =
          'In <span>2 Players</span> mode, both sides are controlled on this device.';
      } else {
        modeLabelEl.textContent = `Mode: Vs ${botElo} Elo Bot`;
        modeHintEl.innerHTML =
          `You play <span>White</span>. The bot plays at ${botElo} Elo strength as Black.`;
      }

      // Detailed status
      if (game.in_checkmate()) {
        const winner = turn === "w" ? "Black" : "White";
        gameStatusTextEl.innerHTML =
          '<span class="status-win">Checkmate.</span> ' +
          winner +
          " wins!";
        // Show checkmate modal
        showCheckmateModal(winner);
      } else if (game.in_stalemate()) {
        gameStatusTextEl.innerHTML =
          '<span class="status-draw">Stalemate.</span> Drawn position.';
      } else if (game.in_threefold_repetition()) {
        gameStatusTextEl.innerHTML =
          '<span class="status-draw">Threefold repetition.</span> Game drawn.';
      } else if (game.insufficient_material()) {
        gameStatusTextEl.innerHTML =
          '<span class="status-draw">Insufficient material.</span> Game drawn.';
      } else if (game.in_draw()) {
        gameStatusTextEl.innerHTML =
          '<span class="status-draw">Draw.</span> No progress possible.';
      } else if (botThinking && mode === "bot") {
        gameStatusTextEl.innerHTML =
          '<span class="status-strong">Bot thinking…</span> Just a moment.';
      } else if (game.in_check()) {
        gameStatusTextEl.innerHTML =
          (turn === "w" ? "White" : "Black") +
          ' is in <span class="status-strong">check</span>.';
      } else {
        gameStatusTextEl.textContent =
          (turn === "w" ? "White" : "Black") + " to move.";
      }
    }

    function resetMoves() {
      movePairs = [];
      movesGridEl.innerHTML = "";
    }

    function addMoveToHistory(move) {
      // move.san contains the SAN notation (e.g., "e4", "Nf3", "Qxe5+")
      const isWhiteMove = move.color === "w";

      if (isWhiteMove) {
        const index = movePairs.length + 1;
        movePairs.push({
          index,
          white: move.san,
          black: "",
        });
      } else {
        if (movePairs.length === 0) {
          // Shouldn't happen, but just in case
          movePairs.push({
            index: 1,
            white: "",
            black: move.san,
          });
        } else {
          movePairs[movePairs.length - 1].black = move.san;
        }
      }

      // Re-render history
      movesGridEl.innerHTML = "";
      for (const pair of movePairs) {
        const idxEl = document.createElement("div");
        idxEl.className = "move-index";
        idxEl.textContent = pair.index + ".";

        const whiteEl = document.createElement("div");
        whiteEl.className = "move-cell white";
        whiteEl.textContent = pair.white || "—";
        if (!pair.white) whiteEl.classList.add("empty-cell");

        const blackEl = document.createElement("div");
        blackEl.className = "move-cell black";
        blackEl.textContent = pair.black || "—";
        if (!pair.black) blackEl.classList.add("empty-cell");

        movesGridEl.appendChild(idxEl);
        movesGridEl.appendChild(whiteEl);
        movesGridEl.appendChild(blackEl);
      }

      // Auto-scroll to bottom
      const container = document.getElementById("movesContainer");
      container.scrollTop = container.scrollHeight;
    }

    function handleSquareClick(squareName) {
      if (botThinking) return;
      if (game.game_over()) return;

      const piece = game.get(squareName);
      const turn = game.turn();

      if (!selectedSquare) {
        // Select piece if it's the side to move
        if (!piece) return;

        if (piece.color !== turn) return;

        // In bot mode, human is always white; block selecting black pieces
        if (mode === "bot" && piece.color === "b") return;

        selectedSquare = squareName;
        possibleMoves = game
          .moves({ square: selectedSquare, verbose: true })
          .map((m) => m.to);

        renderPosition();
        highlightSelectionAndMoves();
      } else {
        if (squareName === selectedSquare) {
          // Deselect on second click on same square
          clearSelection();
          renderPosition();
          return;
        }

        // Attempt move
        const move = game.move({
          from: selectedSquare,
          to: squareName,
          promotion: "q",
        });

        if (move) {
          lastMove = { from: move.from, to: move.to };
          clearSelection();
          renderPosition();
          addMoveToHistory(move);
          updateStatusText();

          if (!game.game_over() && mode === "bot" && game.turn() === "b") {
            // Bot plays black only
            requestBotMove();
          }
        } else {
          // Invalid move; maybe selecting another piece of same color
          const newPiece = game.get(squareName);
          if (newPiece && newPiece.color === turn) {
            selectedSquare = squareName;
            possibleMoves = game
              .moves({ square: selectedSquare, verbose: true })
              .map((m) => m.to);
            renderPosition();
            highlightSelectionAndMoves();
          } else {
            // Just clear selection
            clearSelection();
            renderPosition();
          }
        }
      }
    }

    function highlightSelectionAndMoves() {
      document
        .querySelectorAll(".square")
        .forEach((sq) => sq.classList.remove("selected", "move-highlight"));

      if (selectedSquare) {
        const selSq = document.querySelector(
          `.square[data-square="${selectedSquare}"]`
        );
        if (selSq) selSq.classList.add("selected");
      }

      possibleMoves.forEach((dest) => {
        const sq = document.querySelector(`.square[data-square="${dest}"]`);
        if (sq) sq.classList.add("move-highlight");
      });
    }

    // --- Bot logic with different Elo levels ---
    function evaluateMove(move, gameState) {
      let score = 0;
      
      // Material value (simplified)
      const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      
      // Captures
      if (move.captured) {
        score += pieceValues[move.captured] * 10;
      }
      
      // Check
      if (move.san.includes('+')) {
        score += 5;
      }
      
      // Checkmate
      if (move.san.includes('#')) {
        score += 1000;
      }
      
      // Center control (e4, e5, d4, d5)
      const centerSquares = ['e4', 'e5', 'd4', 'd5'];
      if (centerSquares.includes(move.to)) {
        score += 2;
      }
      
      // Piece development (knights and bishops to good squares)
      if ((move.piece === 'n' || move.piece === 'b') && ['c3', 'f3', 'c6', 'f6', 'b3', 'g3', 'b6', 'g6'].includes(move.to)) {
        score += 1;
      }
      
      // Avoid moving into check (handled by chess.js, but we can penalize risky moves)
      // This is simplified - a real engine would do deeper analysis
      
      return score;
    }

    function chooseBotMove(moves) {
      if (moves.length === 0) return null;

      // Evaluate all moves
      const evaluatedMoves = moves.map(move => ({
        move,
        score: evaluateMove(move, game)
      }));

      // Sort by score (best first)
      evaluatedMoves.sort((a, b) => b.score - a.score);

      // Different strategies based on Elo
      if (botElo <= 300) {
        // 300 Elo: Mostly random, slightly prefers captures
        if (Math.random() < 0.7) {
          return moves[Math.floor(Math.random() * moves.length)];
        }
        const captures = moves.filter((m) => m.captured);
        if (captures.length && Math.random() < 0.5) {
          return captures[Math.floor(Math.random() * captures.length)];
        }
        return moves[0];
      } else if (botElo <= 500) {
        // 500 Elo: Prefers captures, sometimes random
        const captures = moves.filter((m) => m.captured);
        if (captures.length && Math.random() < 0.6) {
          return captures[Math.floor(Math.random() * captures.length)];
        }
        if (Math.random() < 0.4) {
          return moves[Math.floor(Math.random() * moves.length)];
        }
        return evaluatedMoves[0].move;
      } else if (botElo <= 700) {
        // 700 Elo: Often picks best move, sometimes random
        if (Math.random() < 0.5) {
          return evaluatedMoves[0].move;
        }
        // Pick from top 30% of moves
        const topMoves = evaluatedMoves.slice(0, Math.max(1, Math.floor(evaluatedMoves.length * 0.3)));
        return topMoves[Math.floor(Math.random() * topMoves.length)].move;
      } else if (botElo <= 900) {
        // 900 Elo: Usually picks from top moves
        if (Math.random() < 0.7) {
          return evaluatedMoves[0].move;
        }
        const topMoves = evaluatedMoves.slice(0, Math.max(1, Math.floor(evaluatedMoves.length * 0.4)));
        return topMoves[Math.floor(Math.random() * topMoves.length)].move;
      } else if (botElo <= 1100) {
        // 1100 Elo: Mostly best moves, occasional suboptimal
        if (Math.random() < 0.8) {
          return evaluatedMoves[0].move;
        }
        const topMoves = evaluatedMoves.slice(0, Math.max(1, Math.floor(evaluatedMoves.length * 0.5)));
        return topMoves[Math.floor(Math.random() * topMoves.length)].move;
      } else if (botElo <= 1300) {
        // 1300 Elo: Almost always best or near-best
        if (Math.random() < 0.9) {
          return evaluatedMoves[0].move;
        }
        const topMoves = evaluatedMoves.slice(0, Math.max(1, Math.floor(evaluatedMoves.length * 0.6)));
        return topMoves[Math.floor(Math.random() * topMoves.length)].move;
      } else {
        // 1500 Elo: Always picks from top moves
        const topMoves = evaluatedMoves.slice(0, Math.max(1, Math.floor(evaluatedMoves.length * 0.7)));
        return topMoves[Math.floor(Math.random() * topMoves.length)].move;
      }
    }

    function requestBotMove() {
      botThinking = true;
      updateStatusText();

      setTimeout(() => {
        if (game.game_over()) {
          botThinking = false;
          updateStatusText();
          return;
        }

        const moves = game.moves({ verbose: true });
        if (!moves.length) {
          botThinking = false;
          updateStatusText();
          return;
        }

        const chosen = chooseBotMove(moves);
        if (!chosen) {
          botThinking = false;
          updateStatusText();
          return;
        }

        const move = game.move({
          from: chosen.from,
          to: chosen.to,
          promotion: "q",
        });

        if (move) {
          lastMove = { from: move.from, to: move.to };
          renderPosition();
          addMoveToHistory(move);
        }

        botThinking = false;
        updateStatusText();
      }, 400 + (botElo / 10)); // Higher Elo = slightly longer thinking time
    }

    // --- Mode & new game ---
    function setMode(newMode) {
      mode = newMode;
      const buttons = modeToggleEl.querySelectorAll("button[data-mode]");
      buttons.forEach((btn, idx) => {
        btn.classList.toggle("active", btn.dataset.mode === newMode);
      });

      // Move highlight pill
      if (newMode === "human") {
        modeHighlightEl.style.transform = "translateX(0%)";
        eloSelector.style.display = "none";
      } else {
        modeHighlightEl.style.transform = "translateX(100%)";
        eloSelector.style.display = "block";
      }

      startNewGame();
    }

    function setBotElo(elo) {
      botElo = parseInt(elo);
      if (mode === "bot") {
        updateStatusText();
      }
    }

    function showCheckmateModal(winner) {
      winnerNameEl.textContent = winner;
      checkmateModal.classList.add("show");
    }

    function hideCheckmateModal() {
      checkmateModal.classList.remove("show");
    }

    function startNewGame() {
      game.reset();
      clearSelection();
      lastMove = null;
      resetMoves();
      renderPosition();
      updateStatusText();
      hideCheckmateModal();
    }

    // --- Event listeners ---
    boardEl.addEventListener("click", (event) => {
      const squareEl = event.target.closest(".square");
      if (!squareEl) return;
      const squareName = squareEl.dataset.square;
      if (!squareName) return;
      handleSquareClick(squareName);
    });

    newGameBtn.addEventListener("click", () => {
      startNewGame();
    });

    modeToggleEl.addEventListener("click", (event) => {
      const btn = event.target.closest("button[data-mode]");
      if (!btn) return;
      const newMode = btn.dataset.mode;
      if (newMode && newMode !== mode) {
        setMode(newMode);
      }
    });

    modalNewGameBtn.addEventListener("click", () => {
      startNewGame();
    });

    modalCloseBtn.addEventListener("click", () => {
      hideCheckmateModal();
    });

    // Close modal when clicking outside
    checkmateModal.addEventListener("click", (event) => {
      if (event.target === checkmateModal) {
        hideCheckmateModal();
      }
    });

    eloSelector.addEventListener("change", (event) => {
      setBotElo(event.target.value);
      if (mode === "bot" && game.turn() === "b" && !game.game_over() && !botThinking) {
        // If it's bot's turn, make a move with new Elo
        requestBotMove();
      }
    });

    // --- Initial render ---
    eloSelector.value = botElo.toString(); // Set initial Elo selector value
    createBoardSquares();
    renderPosition();
    updateStatusText();
  </script>
</body>
</html>
